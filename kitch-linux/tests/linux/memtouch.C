/******************************************************************************
 * K42: (C) Copyright IBM Corp. 2003.
 * All Rights Reserved
 *
 * This file is distributed under the GNU LGPL. You should have
 * received a copy of the license along with K42; see the file LICENSE.html
 * in the top-level directory for more details.
 *
 * $Id: memtouch.C,v 1.4 2003/12/03 18:52:46 mostrows Exp $
 *****************************************************************************/
/*****************************************************************************
 * Module Description: Scans memory, deduces page-fault times
 * **************************************************************************/
#include <unistd.h>
#include <sys/mman.h>
#include <stdio.h>
#include <time.h>
#include <sys/time.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <asm/unistd.h>
#define PAGE_SIZE 4096
char fileName[64] = "/tmp/pftest.XXXXXX";

#if 0
long int
faultCount() {
    int x = open("/proc/self/stat", O_RDONLY);
    char buf[512];
    int len = read(x, buf, 512);
    int i = 0;
    int word = 1;
    char *min=NULL;
    char *maj=NULL;
    char *p = &buf[0];
    while (i<len) {
	if (buf[i]==' ') {
	    ++word;
	    p = &buf[i+1];
	}
	if (word == 10) {
	    min = p;
	} else if (word == 12) {
	    maj = p;
	    break;
	}
	++i;
    }
    return strtol(min, NULL, 10) +  strtol(maj, NULL, 10);
}
#else
long int
faultCount() {
    return 0;
}
#endif

double sub(struct timeval a, struct timeval b, struct timeval &diff)
{
    diff.tv_usec = a.tv_usec - b.tv_usec;
    while (diff.tv_usec<0) {
	diff.tv_usec += 1000000;
	a.tv_sec -= 1;
    }
    while (diff.tv_usec>1000000) {
	diff.tv_usec -= 1000000;
	a.tv_sec += 1;
    }
    diff.tv_sec = a.tv_sec - b.tv_sec;
    return diff.tv_sec * 1000000 + diff.tv_usec;
}


#define barrier() __asm__ __volatile__ ("": : :"memory")


// For a mapping "key" pages in size, we will be able to generate
// "z-1" unique memory references (each causing a fault) in
// a pseudo-random pattern by iterating through the multiplicative
//               *
// group within Z  generated by "p"
//               z
// The tough part here is do identify "z" and "p" with, z being the right
// size so that p generates the correct group.
struct group{
    unsigned int key;
    unsigned int z;
    unsigned int p;
};

struct group groups[]={
    {0x400, 1019, 2},
    {0x800, 2039, 7},
    {0x1000,4093, 2},
    {0x2000,8191, 17},
    {0x4000,16381,2},
    {0x8000,32579,7},
    {0,},
};






double
runtest(char* start, size_t length, int write)
{
    volatile char x;
    struct timeval s1, e1;
    struct timeval s2, e2;
    unsigned int numPages = length/PAGE_SIZE;
    group *g = &groups[0];
    while (g->key && g->key!=numPages) {
	++g;
    }

    unsigned int startPage= 1;
    unsigned int curr =startPage;
    unsigned int page = 0;
    numPages = g->z - 1;
    long fCount[4];
    if (write) {

	fCount[0] = faultCount();
	gettimeofday(&s1, NULL);
	while (page++ < numPages) {
	    barrier();
	    start[curr*PAGE_SIZE] = x;
	    curr = (curr * g->p) % g->z;
	}
	gettimeofday(&e1, NULL);
	fCount[1] = faultCount();

	page = 0;
	curr = startPage;
	start[curr*PAGE_SIZE] = x;
	fCount[2] = faultCount();
	gettimeofday(&s2, NULL);
	while (page++ < numPages) {
	    barrier();
	    start[curr*PAGE_SIZE] = x;
	    curr = (curr * g->p) % g->z;
	}
	gettimeofday(&e2, NULL);
	fCount[3] = faultCount();

    } else {
	fCount[0] = faultCount();
	gettimeofday(&s1, NULL);
	while (page++ < numPages) {
	    barrier();
	    x = start[curr*PAGE_SIZE];
	    curr = (curr * g->p) % g->z;
	}
	gettimeofday(&e1, NULL);
	fCount[1] = faultCount();

	page = 0;
	curr = startPage;
	x = start[curr*PAGE_SIZE];
	fCount[2] = faultCount();
	gettimeofday(&s2, NULL);
	while (page++ < numPages) {
	    barrier();
	    x = start[curr*PAGE_SIZE];
	    curr = (curr * g->p) % g->z;
	}
	gettimeofday(&e2, NULL);
	fCount[3] = faultCount();

    }

    struct timeval d1;
    struct timeval d2;
    struct timeval d3;


    sub(e1, s1, d1);
    sub(e2, s2, d2);
    sub(d1, d2, d3);
//    printf("%ld %ld\n", fCount[1]-fCount[0], fCount[3]-fCount[2]);
    double total = d3.tv_sec * 1000000 + d3.tv_usec;
    return total / numPages;
}


//
// Use a hacked-in linux syscall (#208?) to remove hpte entries
// for a range of memory and see how long it takes to fault them in
//
#define __NR_mflush 208

#define __syscall_ret(t)				\
	return (__sc_err & 0x10000000 ? errno = __sc_ret, \
		__sc_ret = ((unsigned long)-1) : 0), \
	       (t) __sc_ret

#define __syscall2(type,name,type1,arg1,type2,arg2)			\
type name(type1 arg1, type2 arg2)					\
{									\
	unsigned long __sc_ret, __sc_err;				\
	{								\
		register unsigned long __sc_0 __asm__ ("r0");		\
		register unsigned long __sc_3 __asm__ ("r3");		\
		register unsigned long __sc_4 __asm__ ("r4");		\
									\
		__sc_3 = (unsigned long) (arg1);			\
		__sc_4 = (unsigned long) (arg2);			\
		__sc_0 = __NR_##name;					\
		__asm__ __volatile__					\
			("sc           \n\t"				\
			 "mfcr %1      "				\
			: "=&r" (__sc_3), "=&r" (__sc_0)		\
			: "0"   (__sc_3), "1"   (__sc_0),		\
			  "r"   (__sc_4)				\
			: "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12");\
		__sc_ret = __sc_3;					\
		__sc_err = __sc_0;					\
	}								\
	__syscall_ret (type);					\
}
__syscall2(int, mflush, unsigned long, start, unsigned long, end);
void
hpteEntry(size_t length)
{
    char* start = (char*)mmap(NULL, length, PROT_READ|PROT_WRITE,
			      MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);

    if (~0UL == (unsigned long)start) {
	printf("Error: %d %s\n", errno, strerror(errno));
    }
    double result1 = runtest(start, length, 1);

    int ret = mflush((unsigned long)start, ((unsigned long)start) + length);
    if (ret < 0) {
	if (errno==ENOSYS)
	    return;
	printf("mflush error: %d %s\n", errno, strerror(errno));
    }

    double result2 = runtest(start, length, 1);


    munmap(start, length);
    printf("0x%4lx hpteEntry write: %.2lfus %.2lfus\n",
	   length/PAGE_SIZE, result1, result2);
}



void
anonWrite(size_t length)
{
    char* start = (char*)mmap(NULL, length, PROT_READ|PROT_WRITE,
			      MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);

    if (~0UL == (unsigned long)start) {
	printf("Error: %d %s\n", errno, strerror(errno));
    }
    double result = runtest(start, length, 1);

    munmap(start, length);
    printf("0x%4lx anon write: %.2lfus\n", length/PAGE_SIZE, result);
}

void
forkFault(size_t length)
{
    char* start = (char*)mmap(NULL, length, PROT_READ|PROT_WRITE,
			      MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);

    if (~0UL == (unsigned long)start) {
	printf("Error: %d %s\n", errno, strerror(errno));
    }
    double result1 = runtest(start, length, 1);
    double result2;
    int pipes[2];
    pipe(pipes);
    pid_t pid = fork();
    if (pid==0) {
	result2 = runtest(start, length, 1);
	write(pipes[1], &result2, sizeof(result2));
	exit(0);
    } else {
	read(pipes[0], &result2, sizeof(result2));
	wait(NULL);
    }

    double result3 = runtest(start, length, 1);

    munmap(start, length);
    printf("0x%4lx fork: pre: %.2lfus child: %.2lfus parent: %.2lfus\n",
	   length/PAGE_SIZE, result1, result2, result3);
}


void
cowMng(size_t length)
{

    int fd = open(fileName, O_RDWR);
    char* shared = (char*)mmap(NULL, length, PROT_READ|PROT_WRITE,
			       MAP_SHARED, fd, 0);

    char* priv = (char*)mmap(NULL, length, PROT_READ|PROT_WRITE,
			     MAP_PRIVATE, fd, 0);

    if (~0UL == (unsigned long)shared) {
	printf("Error: %d %s\n", errno, strerror(errno));
    }

    if (~0UL == (unsigned long)priv) {
	printf("Error: %d %s\n", errno, strerror(errno));
    }

    double result1 = runtest(priv, length, 0);
    double result2 = runtest(shared, length, 1);
    double result3 = runtest(priv, length, 1);
    munmap(priv, length);
    munmap(shared, length);
    printf("0x%4lx touch: %6.2lfus shared: %6.2lfus private: %6.2lfus\n",
	   length/PAGE_SIZE, result1, result2, result3);
    close(fd);
}

void
cowMng2(size_t length)
{

    int fd = open(fileName, O_RDWR);
    char* shared = (char*)mmap(NULL, length, PROT_READ|PROT_WRITE,
			       MAP_SHARED, fd, 0);

    char* priv = (char*)mmap(NULL, length, PROT_READ|PROT_WRITE,
			     MAP_PRIVATE, fd, 0);

    if (~0UL == (unsigned long)shared) {
	printf("Error: %d %s\n", errno, strerror(errno));
    }

    if (~0UL == (unsigned long)priv) {
	printf("Error: %d %s\n", errno, strerror(errno));
    }

    double result1 = runtest(priv, length, 1);
    double result2 = runtest(shared, length, 1);
    munmap(priv, length);
    munmap(shared, length);
    printf("0x%4lx shared: %6.2lfus private: %6.2lfus\n",
	   length/PAGE_SIZE, result2, result1);
    close(fd);
}

int
main(int argc, char **argv)
{

    int fd = mkstemp(fileName);

    static char buf[PAGE_SIZE] = { 'a', };
    int i = 0;

    int x = open("/proc/self/stat", O_RDONLY);
    int onK42 = 0;
    if (x<0) {
	onK42 = 1;
    } else {
	close(x);
    }

    int length = PAGE_SIZE<<16;

    while (i<length) {
	if (length - i > PAGE_SIZE) {
	    write(fd, buf, PAGE_SIZE);
	    i+=PAGE_SIZE;
	} else {
	    write(fd, buf, length-i);
	    i = length;
	}
    }
    close(fd);

    for (int i=15; i> 9; i--) {
	cowMng(PAGE_SIZE<<i);
	cowMng(PAGE_SIZE<<i);
    }

    for (int i=10; i< 16; i++) {
	cowMng(PAGE_SIZE<<i);
	cowMng(PAGE_SIZE<<i);
    }

    for (int i=15; i> 9; i--) {
	cowMng2(PAGE_SIZE<<i);
	cowMng2(PAGE_SIZE<<i);
    }

    if (!onK42) {
	for (int i=10; i< 16; i++) {
	    hpteEntry(PAGE_SIZE<<i);
	    hpteEntry(PAGE_SIZE<<i);
	}
    }
    for (int i=10; i< 16; i++) {
	anonWrite(PAGE_SIZE<<i);
	anonWrite(PAGE_SIZE<<i);
    }

    for (int i=10; i< 16; i++) {
	forkFault(PAGE_SIZE<<i);
	forkFault(PAGE_SIZE<<i);
    }

    close(fd);
    unlink(fileName);
}
