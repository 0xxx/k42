# ############################################################################
# K42: (C) Copyright IBM Corp. 2000.
# All Rights Reserved
#
# This file is distributed under the GNU LGPL. You should have
# received a copy of the License along with K42; see the file LICENSE.html
# in the top-level directory for more details.
#
#  $Id: M.common,v 1.3 2003/01/24 19:11:36 marc Exp $
# ############################################################################
#########
#
# SPEC Master Makefile for 057.sdet
#
BENCHNAME = sdet
BENCHNUMBER = 057

RUNSERIES= 1 # 5 10

# LABEL is the run identifier
LABEL=test
# The results from a sequence run are archived in the $SPEC/test.results
# directory under the {BENCHNAME}
TRESULTS = $(TESTRESULTS)/$(BENCHNUMBER).$(BENCHNAME)
#
# This makes sure that csh or ksh users don't invoke the wrong shell.
# for portability, all of the shell commands are Bourne shell.
SHELL = /bin/sh
# macros for timing
UTIME = `pwd`/bin/time
SIZE = /bin/size
TDATE = `date +%m%d%H%M`
FREEZDATE=`cat frozendate`

RUNPLACES = Tmp
SHORT = 1
FIXED = 16
# default workload C compiler
#default workload flags
WCFLAGS =
# Vendor makefile wrappers can override these.
# LIBS is required so you can specify default additional
# libraries for compilation.  EXTRA_LIBS is used for vendor specific
# default libraries.  A vendor wrapper may need to overwrite LIBS for
# some special circumstances (termlib vs. termio).
OPT = -O
OBJ=o
LIBS =
# vendor makefile wrappers must override these if needed
#!!!these should "never" be changed !!!
#!!!(vendor makefile wrappers depend on them) !!!
EXTRA_CFLAGS =
EXTRA_FFLAGS =
EXTRA_LDFLAGS =
EXTRA_LIBS =
# vendor makefile wrappers shouldn't override these (typically)
# Place here any flags that you believe should exist for all
# compilers/loaders.  (E.G. -w for Fortran to suppress warning messages).
STD_CFLAGS =
STD_FFLAGS =
STD_LDFLAGS =
#!!!these should "never" be changed !!!
#!!!(vendor makefile wrappers depend on them) !!!
CFLAGS= ${STD_CFLAGS} ${OPT} ${EXTRA_CFLAGS}
FFLAGS= ${STD_FFLAGS} ${OPT} ${EXTRA_FFLAGS}
LDFLAGS= ${STD_LDFLAGS} ${OPT} ${EXTRA_LDFLAGS}
# This is built around having a separate result directory where
# all runs are done.  The output files will always be created in the
# result directory.  It also implies that there is a directory called
# result.ref as the implicit directory that contains known reference
# output for the program.  By changing OUTMACH, you can validate new
# results against results.machine where machine is generated by
# someone else.  This will facilitate trading result directories
# among members.
RESULTDIR = result
OUTMACH = ref
# In addition, we have created a structure which allows for multiple sets
# of input files.  For example, with spice, the reference input set will
# take approximately 1 hour to run.  There is an input set which will take
# approximately 5 minutes to run.  This is placed in the directory:
# ${INPUTDIR}.short
# Thus, to run the short version of spice you could say:
# make INMACH=short OUTMACH=short validate
# which would run spice2g6, put the results in ${RESULTDIR} and then
# compare the listed result files against files found in
# $RESULTDIR}.${OUTMACH}
INPUTDIR = input
INMACH = ref
# Specify the program that will compare the generated results with the 
# reference results.  Typically this will be diff or spiff.  Note that you
# should give the non-file arguments here.
DIFFER = diff
# INFILES is a list of files to copy into the RESULTDIR to be used
# when running the benchmark.	MORE_INFILES is used to link a set of
# files over to RESULTDIR when the files are too big to copy.
# Note that if the list is null, there is no detrimental effect.
# typically this is set to ${INPUTDIR}.${INMACH}/*
INFILES = 
MORE_INFILES = run.${BENCHNAME}
# These are the arguments that are required for the benchmark programs.
# Note that the template assumes a single executable, special fixes must
# be made in the event of multiple executables.  Typically redirection of
# input (if required) is done here.  Stderr and Stdout redirection are
# handled by the run target.
BENCHARGS =
# This is the list of output files that are compared with the generated
# results in the result directory.  Result.out and time.out are always
# generated by the run target.  List any additional files that the program
# generated
# When performing your initial setup, make sure that you provide both
# result.out and a time.out in the ${RESULTDIR}.${OUTMACH} directory.
OUTFILES = result.out time.out
# Provide a list of the object modules which are required to link the
# executable.
OBJS = ${OBJ}
# Make sure that you specify the correct compiler for linking!!!
# LINKCOMPILER = ${WCC}
LINKCOMPILER = ${CC}
# By default, the generated output is compared against the reference
# output.
validate all: run
# save your generated results in a vendor-specific directory
save:
	@if test ! -d result.${MACHID}; then mkdir result.${MACHID}; fi
	@mv result/result.out result/time.out result.${MACHID}
run runsequence:	warning sequence seqrun doresults
warning:
	@cat ./achtung1 > /dev/tty
	@cat ./achtung2 > /dev/tty
	@touch warning
sequence:
	@echo "${RUNSERIES}" > Sequence
doresults:
	@mkgraphtbl > ${RESULTDIR}/graph.table
	@df >> l.${FREEZDATE}
	@cp ${RESULTDIR}/graph.table ${TRESULTS}/${LABEL}/g.${FREEZDATE}
	@cp l.* ${TRESULTS}/${LABEL}/.
	@rm l.*
compare:
	@for i in ${RUNSERIES}; \
		do bin/compare.sh $$i;  \
	done
	@saveres.sh
	@if test -f ${RESULTDIR}/err.*; then echo ;\
		echo "** There was an error, the message follows **" ;\
		cat ${RESULTDIR}/err.*; Checklist; exit 1; fi
	@echo
	@echo; echo "One User Reference Times:"
	@cat ${RESULTDIR}.${OUTMACH}/time.out
	@echo; echo "Run Times:"
	@cat ${RESULTDIR}/time.out
# Run
seqrun: compile dirs prepare
#	@echo Ignore syntax error from the following line
	-@for i in ${MORE_INFILES}; do ln $$i ${RESULTDIR}/$$i; done
	@ echo
	@if expr "${EXTRA_CFLAGS}" : '.*TIME.*' \| "${EXTRA_CFLAGS}"\
		: '.*SAR.*' > /dev/null;\
	then > ${RESULTDIR}/dotime; fi
	@for i in ${RUNSERIES}; \
		do echo "Starting benchmark at `date` with $$i script(s) - wait!!!" > /dev/tty;\
		rm -f ${RESULTDIR}/* ;\
		${UTIME} ./run.sdet $$i > ${RESULTDIR}/result.out 2> \
			${RESULTDIR}/time.out ;\
		echo "Finished benchmark at `date` - check result directory" \
			> /dev/tty;\
		bin/compare.sh $$i ;\
                sync ;\
		saveres.sh ;\
		if test -f ${RESULTDIR}/err.*;\
		then echo;\
			echo "** There was an error, the message follows **";\
			cat ${RESULTDIR}/err.*;\
			Checklist;\
			exit 1;\
		else echo ;\
			grep K42 ${RESULTDIR}/result.out | \
			sed 's/K42Elapsed time:/real/g' >  \
			${RESULTDIR}/time.out; \
			bin/calcmetric ${RESULTDIR}/t[hi]* 2>> \
			${RESULTDIR}/result.out;\
			bin/calcmetric ${RESULTDIR}/t[hi]* >> \
			${RESULTDIR}/result.out;\
			echo ;\
			cat ${RESULTDIR}/result.out >> l.${FREEZDATE};\
			cat ${RESULTDIR}/time.out >> l.${FREEZDATE};\
			cat ${RESULTDIR}/thrp.* >> l.${FREEZDATE};\
		fi ;\
	done
	@rm -f prepare
compile:
	@cd tools;\
	make MACHID=${MACHID}\
		EXTRA_CFLAGS="${EXTRA_CFLAGS}"\
		EXTRA_FFLAGS="${EXTRA_FFLAGS}"\
		EXTRA_LDLAGS="${EXTRA_LDLAGS}"\
		EXTRA_LIBS="${EXTRA_LIBS}"\
		OPT="${OPT}"\
		OBJ="${OBJ}"\
		$@
# make sure required directories are present - tar likes to ignore them
dirs:
	@if test ! -d masterclone/edit1; then mkdir masterclone/edit1; fi
	@if test ! -d masterclone/movdest; then mkdir masterclone/movdest; fi
	@if test ! -d ${RESULTDIR}; then mkdir ${RESULTDIR}; fi
${BENCHNAME}: ${OBJS}
	${LINKCOMPILER} ${LDFLAGS} -o $@ ${OBJS} ${LIBS} ${EXTRA_LIBS}
prepare: compile
	@ echo ${RUNPLACES} > Clonedirs
	@ echo "WCC=\"$(WCC)\"" > wcc.env
	@ echo "WCFLAGS=\"$(WCFLAGS)\"" >> wcc.env
	echo "${TDATE}" > frozendate
#
#	Make results directory for archiving results in
#	$TESTRESULTS/$BENCHNUM.$BENCHNAME/r<scripts>.<date>
#	added 1/28/91 at benchathon
#
	@if [ ! -d "${TESTRESULTS}" ] ;\
	then \
		echo "Please create proper SPEC runtime environment by doing: cd ../..; . ./shrc" ; \
		exit 1 ;\
	elif [ ! -d ${TRESULTS} ]; then mkdir ${TRESULTS};\
	fi
	@if [ ! -d ${TRESULTS}/${LABEL} ]; then mkdir ${TRESULTS}/${LABEL}; fi
	@ ./setsdet
	@ touch prepare
clean:
	- /home/root/quick_rm
	cd tools; make clean
	rm -f ${RESULTDIR}/*
	rm -f core

clobber:	clean
	cd tools; make clobber
	cd scripts; rm -f term.*
#	cd output; rm -f *.[s1-9]*
	cd output; for i in 0 1 2 3 4 5 6 7 8 9; do rm -f *.$${i}*;done
	cd /usr/tmp; rm -f err.out thrp.out sdesar sdesar_LAST
	rm -fr ${BENCHNAME} ctags ${RESULTDIR}.${MACHID} ${RESULTDIR}
	rm -f MAX_CLONE_NUM warning RUNSERIES Clonedirs Sequence foo* frozendate
	rm -f Clonepath prepare bin/driver bin/driver.exec wcc.env l.*
	touch CLONEDIR
	for q in `cat CLONEDIR`; do cd $$q && rm -rf clone*; done
	rm -f CLONEDIR

realclean: clobber
	rm -fr Tmp masterclone/edit1 masterclone/movdest
