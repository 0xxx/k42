<!--
  K42: (C) Copyright IBM Corp. 2001.
  All Rights Reserved

  This file is distributed under the GNU LGPL. You should have
  received a copy of the license along with K42; see the file LICENSE.html
  in the top-level directory for more details.

  $Id: cobjOver.sgml,v 1.5 2002/01/09 18:42:52 dilma Exp $
-->
<title>Overview of Clustered Objects</title>

<section>
  <title>Writing an xobject</title>
  <section id="overview">
    <title>Overview</title>
    <para>

      All IPC in K42 is between objects in client (requesting) and
      server (target) address spaces.  The server objects are
      clustered objects (<ulink url="../sys/doc/sys.html">see the
      documentation on writing a clustered object</ulink>).  From the
      header of a server object called, for example, "Object" our
      stub-compiler generates the following objects classes:

    </para>
    <section>
      <title>StubObject</title>
      <para>

	An object in the client address space that has the same
	interface as the server object. It acts as a proxy for all
	communication with the server object. On a method invocation,
	this object marshals arguments into the architecture specific
	transport (i.e., registers, PPC_PAGE...), and transfers
	control to server address space.  The Stub object is not a
	clustered object, but, as described later, is by convention
	embedded in a clustered object.

      </para>
    </section>
    <section>
      <title>MetaObject</title>
      <para>

	An object in the server address space responsible for handling
	the server side of the transport (i.e.,
	marshaling/de-marshaling arguments) and enforcing the
	programmer specified security.

      </para>
      <para>

	The details of the interface are specified by an interface
	definition language, and implemented by header files and
	marshaling/de-marshaling routines generated by a "stub
	compiler".  The K42 approach to this IDL is to extend C++ with
	a small number of "decorations".  These are additional
	keywords, some with values, which are used in the C++
	declarations of the server objects which implement client
	interfaces.  The implementation approach is to provide a
	header file which replaces (using \#DEFINE) each of these
	decorations with a valid C++ equivalent for normal compilation
	of the server programs.

      </para>
      <para>

	The decorates indicate to the stub-compiler which methods
	should be made visible to the client address spaces, the
	security that the XObject should enforce, the relationship
	with other objects in the type system, and how parameters
	should be passed.
      </para>

      <para>
	Decorates can not be modified in subclasses.
      </para>

      <para>

	The decorated declarations are processed by the K42 stub
	compiler to produce the required client and server interface
	programs, and the header files needed by the client to use the
	interface.  For example:

      </para>
      <programlisting><anchor id="prototype">
	<![CDATA[
	virtual SysStatusUval _read(__outbuf(__rc:len) char *buf, __in uval len)
           __xa(read)=0;

	virtual SysStatusUval _write(__inbuf(len) const char *buf, __in uval len)
           __xa(write)=0;
	]]>
      </programlisting>
      <para>

	Notice that the interface is not normally exposed to the end
	user.  Rather, a client wrapper class of some sort uses the
	interface.  In this case, the wrapper would implement read and
	write, using<function> _read</function> and
	<function>_write</function> as needed.

      </para>
      <para>

	The decorations in the example are
	<function>__outbuf</function>,
	<function>__in</function>,<function>__inbuf</function>
	specifying <xref linkend="parameters"> and
	<function>__xa</function> specifying <xref
	linkend="security">.

    </para>
    </section>
  </section>
  <section id="parameters">
    <title>Parameter passing</title>
    <section>
      <title>Standard parameters</title>
      <para>

	Normal C++ parameter passing of scalars and structs, by value,
	by reference, and by pointer are all supported.  Three cases,
	<function>__in</function>, <function>__out</function>, and
	<function>__inout</function> are available.  The default, if
	no decoration is given, is always <function>__in</function>.  Only
	<function>_in</function> is allowed for value parameters.

      </para>
      <para>

	All parameter passing is, of course, by value and value
	return, since the caller is in a different address space.
	Processing for <function>__in</function> and
	<function>__out</function> are independent, and
	<function>__inout</function> requests both.  For reference and
	pointer parameters, a temporary is created in the server.  If
	<function>__in</function> is specified, the temporary is
	initialized with the client input value.  If
	<function>__out</function> is specified, the final value of
	the temporary is passed back to the client and assigned to the
	client variable.  In the pointer case, it is the value pointed
	to, not the pointer, that is being passed.

      </para>
    </section>
    <section>
      <title>Buffer parameters</title>
      <para>
	
	In addition to normal parameter passing, the IDL supports
	passing of various kinds of buffers, including the special
	case of null terminated strings.

      </para>
      <para>

	The parameter is always specified as an array pointer, such as
	char* or uval*.  But the decoration is
	<function>__inbuf(inlen)</function>,
	<function>__outbuf(outlen,maxoutlen)</function>, or
	<function>__inoutbuf(inlen,outlen,maxoutlen)</function>.  As
	in the normal case, <function>_inoutbuf</function> is a simple
	combination of <function>__inbuf</function> and
	<function>__ioutbuf</function>.

      </para>
      <para>

	<function>__inbuf(inlen)</function> causes inlen elements of
	the specified input array to be transfered to the server.  The
	server receives a pointer to the array.  Note that the array
	size is expressed in elements, not bytes.  If the parameter
	type is a character pointer, inlen may be specified as "*", in
	which case the length of the character array taken as a null
	terminated string will be used.

      </para>
      <para>
	<function>__outbuf(outlen,maxoutlen)</function> causes outlen
	elements of the specified output array to be transfered back to the
	client's buffer.  On the server, a pointer to a buffer of size
	maxoutlen elements is passed to the server method.  The server is
	expected to fill that buffer with the results to be passed back.
	Again, if outlen is specified as "*", the null terminated character
	string length will be used.
      </para>
      <para>
	In all cases, the length parameters may be specified using other
	parameter symbols of the method as well as constants.  If the
	maximum buffer length is a parameter symbol, it must be an
	<function>__in</function> parameter.  In addition, the special
	symbol <function>__rc</function> may be used for outlen, in which
	case the method return value is used to specify the length.  See
	prototype above for an example of this usage.
      </para>
    </section>
  </section>
  <section>
    <title>Hidden Parameters</title>
    <para>

      All the parameters discussed above are passed from the client to
      the server.  There are two special parameters that a server may
      need which cannot be supplied by the client, but are instead
      supplied by the underlying infrastructure.  These are the pid of
      the calling client, and the xhandle used for the request.  The
      keywords <function>__CALLER_PID</function> and
      <function>__XHANDLE</function> are used to specify these
      parameters. For example, the functions:

      <programlisting>
	<![CDATA[
	virtual SysStatus _foo(__CALLER_PID pid);
	virtual SysStatus _bar(__XHANDLE xhandle);
	]]>
      </programlisting>

      result in the following prototypes in the stub:

      <programlisting>
	<![CDATA[
	virtual SysStatus _foo();
	virtual SysStatus _bar();
	]]>
      </programlisting>

      Where the client invokes the stub with no arguments, and the
      corresponding server object methods are invoked with the correct
      arguments.  The pid is generally used where authentication to
      establish new connections to objects is required, i.e., where
      one needs the pid to look up the capabilities of that
      process. The security issues in invoking an existing object is
      described in the next section.  The xhandle is generally used
      for <xref linkend="per-client">maintaining
      client specific state.

    </para>
  </section>
  <section id="security">
    <title>Security</title>
    <para>

      To control (limit) access, each XObject is associated with a
      specific "matching" client process.  Each XObject contains two
      access rights vectors, one for the matching process, another for
      all other processes. Server object methods are optionally
      labeled with a vector of required rights.  The call is allowed
      only if the caller get these rights from the Xhandle.

    </para>
    <para>

      Some basic access right names are always defined. In defining
      server classes which support IPC, you can optionally define
      additional access rights.  You can also specify, for each IPC
      method, the access rights required by that method.

    </para>
    <variablelist>
      <varlistentry>
	<term>

	  _xadef:

	</term>
	<listitem>
	  <simpara>
	  
	    defines an access right
	  
	  </simpara>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>

	  _xa:

	</term>
	<listitem>
	  <simpara>

	    labels a method with its required access rights or a class
	    with its default required rights for unlabelled methods.

	  </simpara>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>

	  _xa(none):

	</term>
	<listitem>
	  <simpara>

	    "no bits" - if specified for a method, no rights are
	    required, and anyone can call it. This is not the default.
	    If an Xhandle rights vector is "none", only none methods
	    can be called using that Xhandle.
      	  
	  </simpara>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>

	  _xa(processOnly):

	</term>
	<listitem>
	  <simpara>

	    always part of matched rights.  This is the default for
	    methods which do not specify specific rights.

      	  </simpara>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>

	  _xa(controlAccess):
	
	</term>
	<listitem>
	  <simpara>

	    needed to issue a _giveAccess or releaseAccess operation.
	    Most objects should have this in their matched rights, but
	    it is NOT given by default.  Rather, server objects
	    designers must specify it. 

	  </simpara>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>

	  __xa-
	  
	</term>
	<listitem>
	  <simpara>
	    
	    tags normally appear inside virtual method declarations.
	    The standard form is:
	    <msgtext>
	      <programlisting>
		<![CDATA[
		virtual SysStatus
		method(method parameters) __xa(right1:right2...);
		]]>
	      </programlisting>
	    </msgtext>
	  </simpara>
	</listitem>
      </varlistentry>
    </variablelist>
    <para>

      <function>__xadef</function> and default
      <function>__xa</function> tags should appear in the head of the
      class declaration, as in:

      <programlisting>
	<![CDATA[
	class Bonnie : public Obj __xadef(right1:right2...)  __xa(right1:right2...)  { ...
	]]>
      </programlisting>

      In server object which supports IPC, use:

      <programlisting>
	<![CDATA[	
	DEFINE_ACCESS_SERVER(classname,matched rights,unmatched rights).
	]]>
      </programlisting>

      To define the function <function>giveAccessByServer</function>
      which is invoked in the server address space to give access to a
      specific client. There is generally no need to override the
      functions provided by this macro.  When a client address space
      wishes to transfer its capability to access an object to another
      client, it calls the function giveAccessByClient.  This function
      is similar to <function>giveAccessByServer}</function>, but is
      invoked on a client wrapper objects, and it typically calls the
      <function>_giveAccess</function> function on the server object
      (defined in <filename>Obj.H</filename>).  This function can, at
      the most trasfer to the new client the same rights the original
      client had.

    </para>
    <para>

      Often, the interface class is common to server and wrapper.  The
      classname is the name of the interface class, not the name of
      the server object which provides the service and thus contains
      the <function>DEFINE_ACCESS_SERVER</function> statement.  If the
      interface class is also the server object, we are embarrassed by
      a stub gen problem. The stub generator thinks the above macro is
      an invalid piece of <function>C++</function> - which it is.  So
      we guard it with <function>#ifndef _IN_STUBGEN</function> to
      hide it from the stubgen.

    </para>
    <para>

      <function>releaseAccess()</function> is used to remove an
      XObject.  The implementation is in Obj.H, and should never be
      overridden.  It does the basic bookkeeping calls to remove the
      XObject, and ensures that the object is only deleted once.  If
      you have to do something special on an xobject going away, you
      can override the following functions that are invoked as a side
      effect of releaseAccess:

    </para>
    <para>

      <function>handleXObjFree(xhandle)</function>: override this to
      do something special when an xobject is going away.

    </para>
    <para>

      <function>exportedXObjListEmpty()</function>: override this if
      you want to do something special when the last xobject pointing
      to this object goes away.

    </para>
    <para>

      The server implementation of
      <function>_releaseAccess()</function> receives stub calls.  It
      has one parameter, the xhandle.  It is implemented in Obj.H to
      call <function>_releaseAccess(xhandle)</function>.

    </para>

  
  </section>
  <section>
    <title>Wrappers and Method Naming Conventions</title>
    <para>

      Normally, an IPC service is structured as an interface Base
      class, which is stub compiled.  Derived from the Base is a
      BaseImplementation and BaseWrapper.  The BaseWrapper class
      normally contains an instance of the StubBase object.  The
      StubBase class definition and header file is created by the stub
      compiler.

    </para>
    <para>

      See <function>DEFINE_ACCESS_SERVER</function> for macros that
      set up the giveAccessByServer.

    </para>
    <para>

      Conventionally, a method is named as follows:

    </para>
    <para>

      The Base declares methodName and
      <function>_methodName</function>.
      <function>_methodName</function> is an exported declaration
      using the stub compiler extensions.  (see
      <function>_protected</function>, for example).

    </para>
    <para>

      In the BaseImplementation, methodName is defined as the
      implementation of the operation.
      <function>_methodName</function> does any special authentication
      and then calls methodName to provide the service.  (Normally, no
      additional authentication is needed since the access rights
      mechanism is used to control access to the method). methodName
      is thus also available in the server when this is useful.

    </para>
    <para>

      In the BaseWrapper, methodName is defined to use
      <function>stub._methodName</function> to do an IPC to request
      the service.  <function>_methodName</function> is defined to
      return an error - it should not be used in the client.

    </para>
  </section>
  <section>
    <title>The Factory Problem</title>
    <para>

      In our example above, we spoke of a Base interface, a Base
      Implementation, and a Base wrapper.  But how does a client ask a
      server to create an instance of the Base implementation?  Note
      that there will often be several implementations of the
      interface, and the client will want to choose the one
      appropriate to this use.

    </para>
    <para>

      Ignoring for a moment the client/server aspect of this problem,
      consider a normal OO (e.g. C++) situation.  An interface has
      been declared as a pure class.  An implementation class has been
      derived from it.  All uses of instances of the implementation
      are typed by clients as the type of the interface class, not the
      implementation class. But creating an instance requires a call
      on the chosen implementation class, either in the form of a
      "new" or using a static class function.  Often, the parameters
      of the create depend on details of the chosen implementation
      class.  But the client immediately casts the resultant object
      reference to an instance of the interface class.

    </para>
    <para>

      The client server equivalent in K42 is implemented using the
      meta object.  From the client point of view, the stub class
      contains a static function for creating instances of the
      corresponding client class. An XHandle, rather than a pointer,
      is returned. But, above we indicated that the stub represents
      the interface class, not an implementation!

    </para>
    <para>

      To make this work, we normally "stub compile" both the interface
      class and each implementation class.  The only new interface the
      implementation class provides is a static Create function.
      Following the C++ example above, the client calls the Create
      function and gets an XHandle.  But the client installs that
      XHandle in a wrapper for the interface, not a wrapper for the
      implementation.  This wrapper contains a stub for the interface,
      not a stub for the implementation.  As a result, the same
      wrapper serves for all implementations of the interface, and
      code using the wrapper is insensitive to which implementation is
      being called.  This exactly follows the C++ situation.
      Installing the XHandle in a stub for the interface is the
      programming equivalent of casting the C++ pointer up to a
      pointer to the base class.

    </para>
  </section>
  <section>
    <title>Misc hints</title>
    <para>

      Include files includes by a stubcompiled object are, by default,
      not included by the stubcompiler. If you need to include
      something, you must bracket it as follows, where XXX is the name
      of the file all capitalized.

    </para>
    <programlisting>
      <![CDATA[
      #ifndef EXPORT_XXX
      #define EXPORT_XXX
      --- stuff to be included
      #endif // EXPORT_XXX
      ]]>
    </programlisting>
    <section>
      <title>_IN_STUBGEN</title>
      <para>

	Because the stubgnerator compiles the header file without
	including all other headers, some constructs may not compile.
	It is usually effective to guard such content with

      </para>
      <programlisting>
	<![CDATA[
        #ifndef _IN_STUBGEN
        bad stuff
        #endif
	]]>
      </programlisting>
      <para>

	However, all virtual function declarations must be seen by the
	stubgen process to produce a correct program.

      </para>
    </section>
  </section>
  <section id="per-client">
    <title>Maintaining per-client state</title>
    <para>

      As stated above, for each client of a server object there is an
      XBaseObj which maintains the rights of that client.  This object
      is able to maintain one uval (8 bytes) of information for the
      server.  Servers can use this either directly, or as a pointer
      to additional per-client state.

    </para>
    <section>
      <title>Establishing per client data</title>
      <para>

	Per Client data is normally initialized during the
	giveAccessByServer call which produces the new XHandle.  To do
	this, the server must override the giveAccessSetClientData
	method, as in:

      </para>
      <programlisting>
	<![CDATA[
	/* virtual */ SysStatus
	MyClass::giveAccessSetClientData(ObjectHandle &oh, ProcessID toProcID,
	AccessRights match, AccessRights nomatch)
	{
	ClientData *clientData = new ClientData();
	return giveAccessInternal(oh, toProcID, match, nomatch, (uval)clientData);
	}
	]]>
      </programlisting>
    </section>
    <section>
      <title>Using per client data</title>
      <para>

	A client interface is addressed by its XHandle.  This is true
	in the client, where the XHandle is part of the ObjectHandle
	used to call the server.  It is also true in the server.  The
	<function>__XHANDLE</function> declaration in a client method
	causes the XHandle used for the client call to be passed to
	the server method.

      </para>
      <programlisting>
	<![CDATA[
	/* virtual */ SysStatus
	MyClass::_dowork(__XHANDLE xhandle) {
	XHandleTrans::GetClientData(xhandle);
	... do work ...
	};
	]]>
      </programlisting>
    </section>
    <section>
      <title>Freeing per client data</title>
      <para>

	When a client interface is closed, either by releaseAccess or
	because the object or using process is destroyed, there may be
	a need to deal with per client data.  The most likely example
	is when the clientData is in fact a pointer to an allocated
	structure.

      </para>
      <para>

	Freeing an XHandle is a two step process.  At remove time, the
	XHandle is made invalid for new calls.  Some time later, when
	the system can guarantee that all calls that were in progress
	at remove time have finished, the XHandle is actually
	destroyed.

      </para>
      <para>

	It is usually necessary to defer freeing of client data until
	this second step because until then threads may try to
	reference it.  To do this, the server must override
	handleXObjFree to register for a call back. In the example
	below, the static function BeingFreed will be called when it
	is safe to free the client data.  At this late stage, the
	server object itself may no longer exist, so the clean up must
	be done by a class static function.

      </para>
      <programlisting>
	<![CDATA[
	static void BeingFreed(XHandle xhandle) {
        ClientData *clientData;
        clientData = (ClientData*)(XHandleTrans::GetClientData(xhandle));
        delete clientData;
	}
	
	virtual SysStatus handleXObjFree(XHandle xhandle) {
        XHandleTrans::SetBeingFreed(xhandle, BeingFreed);
	}
	]]>
      </programlisting>
      <para>

	The default implementation of releaseAccess, when the last
	xobject is deleted calls the function exportedXObjListEmpty.
	This function can be overridden on a per-object basis to
	destroy the object when the last external reference goes away.

      </para>

      <para>
	For an example of maintaining per-client state, take a look at
	<ulink url="../../lib/libc/io/IOServer.H">
	<filename>IOServer.H</filename></ulink> and <ulink
	url="../../lib/libc/io/IOServer.C"><filename>
	IOServer.C</filename></ulink> 
	or
	<ulink url="../../lib/libc/fslib/ServerFile.H">
	<filename>ServerFile.H</filename></ulink> and <ulink
	url="../../lib/libc/fslib/ServerFile.C"><filename>
	ServerFile.C</filename></ulink>.


      </para>
    </section>
  </section>
  <section>
    <title>Interfaces, Implementations and Templates</title>
    <para>

      In some cases it is useful to have an object that provides IPC
      services to be able to conform to multiple IPC interface
      definitions.  However, since we are unable to use multiple
      inheritance we cannot create an object that inherits the
      properties of two distinct interfaces.  To work around this
      problem, it is possible to decouple the implementation of an IPC
      interface from the interface definition through the use of
      templated objects (for the Meta and X objects).  This allows us
      to create the Meta and X objects necessary for an implementation
      to conform to a particular IPC interface without requiring that
      the implementation be derived from the interface classes.

    </para>
    <para>

      In short, with these template objects if we have some object
      that conforms to a particular IPC interface (by supporting the
      appropriate methods and their signatures) we can generate Meta
      and XObj code to export that interface.

    </para>
    <para>

      To accomplish this, for a particular IPC interface (e.g.,
      ``Foo'') we generate header files ``xobj/TplXFoo.H'' and
      ``meta/TplMetaFoo.H'' (in addition to the standard headers
      ``stub/StubFoo.H'' , ``meta/MetaFoo.H'' and ``xobj/XFoo.H'').
      These two header files provide definitions for template classes
      TplXFoo<!--<T>--> and TplMetaFoo<!--<T>--> respectively.  In
      order for class ``Bar'' to export interface ``Foo'' (which it
      just happens to conform to), we first need to create instances
      of these template objects directed at ``Bar'' (the classes
      TplXFoo<!--<Bar>--> and TplMetaFoo<!--<Bar>--> will export the
      ``Foo'' interface provided by ``Bar'').  We can instantiate
      these templates with the following code inside the
      implementation of ``Bar'':

    </para>
    <programlisting>
      <![CDATA[
      \begin{verbatim}
      #define INSTNAME Bar
      #include <tmpl/TplXBar.I>
      \end{verbatim}
      ]]>
    </programlisting>
    <para>


      Defining the ``INSTNAME'' macro tells the generated code in
      ``tmpl/TplXBar.C'' how to target the template instantiation.
      This is necessary since static members of template object must
      be explicitly instantiated, and thus we need to know the name of
      the class at which this instantiation is being targeted at.

    </para>
    <para>

      One final issue is to consider is how an object such as ``Bar''
      exports the interface at run-time.  The reference to a
      particular XObj is established via a call to the appropriate
      createXHandle method.  Typically this is handled transparently
      (one simply applies the DEFINE_ACCESS_SERVER macro in the
      definition of the class implementing a particular interface).
      Now however, we may have a class which is being used to provide
      multiple different interfaces and thus we cannot rely on
      DEFINE_ACCESS_SERVER to necessarily generate the appropriate
      code (since it would not generate the logic necessary to
      determine which interface a particular instance of a server
      object wants to export).  If one wants one instance of a server
      object to export different interfaces simultaneously one cannot
      rely on DEFINE_ACCESS_SERVER.

    </para>
    <para>

      However, if we have objects that will only export one interface
      at a time, we can simply derive a sub-class that is targeted to
      providing a particular interface (simply by including the
      appropriate DEFINE_ACCESS_SERVER instantiation in the class
      definition).  This latter approach is the one taken with the
      LinuxSock/LinuxUDP class.

    </para>
  </section>

  <section>
    <title> Instatiating Multiple Interfaces </title>
    <para>
      With the templating mechanism outlined above it is possible for an
      object to conform to two different, unrelated interfaces (simply by
      the existence of the appropriate method definitions).  That being so,
      the object has a choice of which XObject to associate with the
      ObjectHandles it creates.  So far we have only considered a scenario
      where the decision as to which XObjects are used are made statically
      (determined in the invocation of the DEFINE_ACCESS_SERVER macro).
    </para>

    <para>
      With a minor extension to the giveAccess\* interfaces we can allow
      for the binding of XObject to ObjectHandle to be determined
      dynamically.  We extend the interface by adding an additional (and
      typically optional) parameter which specifies the type of object to
      be associated with the ObjectHandle we are to create.  This parameter
      is specified as the TypeID associated with the MetaObject associated
      with the interface we wish to bind to the ObjectHandle.
    </para>

    <para>

      In the following example we demonstrate an object creating an
      ObjectHandle to itself that is associated with the VAPageServerNFS
      interface (taken from ../../os/servers/nfs/ServerFileBlockNFS.C):

      <programlisting>
          MetaVAPageServerNFS::init();

          // create an object handle for upcall from kernel FR
          DREF(getRef())->giveAccessByServer(pageOH, _KERNEL_PID,
                                             MetaVAPageServerNFS::typeID());
      </programlisting>


      Note that in the above example we call MetaVAPageServerNFS::init().
      This is necessary to ensure that the infrastructure required for
      VAPageServerNFS interfaces is initialized.
    </para>
  </section>

  <section>
    <title>Examples</title>
    <para>

      This is just an overview starting document, and most of our
      examples in the code are not very up-to-date.  The best examples
      to copy from are:

    </para>
    <itemizedlist spacing="compact">
      <listitem>
	<simpara>
	  <ulink
	  url="../../io/FileLinuxSocket.H"><filename>
	  FileLinuxSocket.H</filename></ulink>
	</simpara>
      </listitem>
      <listitem>
	<simpara>
	  <ulink
	  url="../../io/FileLinuxSocket.C"><filename>
	  FileLinuxSocket.C</filename></ulink>
	</simpara>
      </listitem>
      <listitem>
	<simpara>
	  <ulink url="../../io/StreamServer.H"><filename>
	  StreamServer.H</filename></ulink>
	</simpara>
      </listitem>
      <listitem>
	<simpara>
	  <ulink url="../../io/StreamServer.C"><filename>
	  StreamServer.C</filename></ulink>
	</simpara>
      </listitem>
      <listitem>
	<simpara>
	  <ulink url="../../io/SocketServer.H"><filename>
	  SocketServer.H</filename></ulink>
	</simpara>
      </listitem>
      <listitem>
	<simpara>
	  <ulink url="../../io/NetDataServer.H"><filename>
	  NetDataServer.H</filename></ulink>
	</simpara>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Hints for newbies</title>

    <para>
      The return value of a stub invocation is very useful for debugging
      misuse of XObjects. For example:
      <itemizedList>
	<listitem>
	  <simpara> for _SGENCD(rc) == ENOSPC, check the argument size
	    of your invocation. The whole argument list (including the return
	    code) has to fit into a PPC page (PPCPAGE_MAX_LOAD, defined in
	    the architecture specific file 
	    lib/libc/sys/arch/your_arch_here/ppcCore.H) 
	  </simpara>
	</listitem>
	
      <listitem>
	  <simpara> for _SGENCD(rc) == 1569 (corresponding to target not
	    found), when running MP check if the server object has been
	    started in all the processors. Examples of how this is done
	    can be found in 
	    <ulink url="&topsrc/os/servers/baseServers/baseServer.C"><filename>
		baseServer.C</filename></ulink>
	    and
	    <ulink url="&topsrc/os/servers/nfs/main.C"><filename>
		FileSystemNFS.C</filename></ulink>
	    (startupSecondaryProcessors routine).
	  </simpara>
	</listitem>
	
      </itemizedList>
    </para>
    
    <para>
      Clustered object's methods have to be declared as virtual.
    </para>

  </section>

</section>

<section>
  <title>Hot Swapping</title>
  <para>
    K42 not only allows OS services to be customized to the needs of an
    application, but also allows the customization to be changed,
    on-the-fly, while the service is in use.  For example, we show how K42
    can switch a (per-file) page cache from a centralized implementation to
    one distributed across the processors of a multiprocessor in order to
    adapt to changing access patterns.  K42's ability to customize
    on-the-fly allows the implementation of a service to match the
    instantaneous demands on the service, avoiding the need to comprise an
    implementation to meet a wide variety of different needs.
  </para>

  <para>
    Our on-the-fly customization of system objects requires the object to
    be implemented as a clustered object. Basically, 3 pieces of
    information are needed in the current interface:

    <itemizedlist spacing="compact">
      <listitem>
	<simpara>
	  the reference to the clustered object to be switched
	</simpara>
      </listitem>
      <listitem>
	<simpara>
	  a way to get at the pointer to the new cluster object's root
	</simpara>
      </listitem>
      <listitem>
	<simpara>
	  a data transfer function for object state transfer
	</simpara>
      </listitem>
    </itemizedlist>
  </para>

  <para>
    Suppose we want to start a switch of clustered object implementations
    from A to B. Implementation A is an active clustered object in the
    program with a clustered object reference i.  Currently, we initiate
    the switch by calling:

    <programlisting>
      COSMgr::switchCObj(i, rootB, dataXferAtoB);
    </programlisting>

    where <varname>rootB</varname> is the pointer to the new clustered
    object's root, and <varname>dataXferAtoB</varname> is the pointer to
    the function that performs the state transfer between A and B.
  </para>

  <para>
    We have a bare bone implementation to accomplish the switching of the
    Region object:

    <itemizedlist spacing="compact">
      <listitem>
	<simpara>
	  kitchsrc/os/kernel/mem/RegionDefault.H: is the object we start
	  off with
	</simpara>
      </listitem>
      <listitem>
	<simpara>
	  kitchsrc/os/kernel/mem/RegionReplicated.H is the object we are
	  switching to. In particular, it defines a constructor where the
	  clustered object reference is passed in, and root installation is
	  skipped.  The <function>CreateSwitchReplacement()</function>
	  method calls this constructor.
	</simpara>
      </listitem>
      <listitem>
	<simpara>
	  kitchsrc/os/kernel/bilge/TestSwitch.H contains the code to
	  initiate the switch between the regions. TestSwitch object is
	  used to enable the switch initiation from the user space. The
	  <function>regionXfer()</function> defines the data transfer
	  method.
	</simpara>
      </listitem>
    </itemizedlist>
  </para>

</section>

<section>
  <title>CO Destruction</title>

  <para>
    Starting point for any given object is a call to destroyUnchecked() we
    assume that the destroy method of the CO has already taken care of the
    logical destruction of the objects (other than temporary references)

    <programlisting>
BaseObj::destroyUnchecked()
{
    myRoot->destroy();
    return(0);
}


CObjRoot::destroy() 
{
    markasDeleted();
    DREF(COSMgr::TheCOSMgrRef())->gcAdd(this);	
}


/* virtual */ SysStatus 
COSMgr::gcAdd(CObjRoot *obj)
{
    LTransEntry *lte=(LTransEntry *)obj->getRef();
    GTransEntry *gte=COSMgr::localToGlobal(lte);

    lock.acquire();
    err_printf("COSMgr::add(%lx)\n", obj);

    // This maybe optimized to use only one stage1 list
    // during processing any thing non local should be put directly on the
    // transferArray.  For the moment use an extra list to make things
    // easier.
    if (obj->vpMask() == (Scheduler::GetVP())) {
        stage1LocalList.add(obj);
    } else {
        stage1RemoteList.add(obj);
    }	
    lock.release();
    return 1;
}

    </programlisting>
  </para>

  <para>
Token is rep pointer to previous rep or null if we don't have it !

    <programlisting>

/* virtual */ SysStatus
COSMgr::checkCleanup()
{
     acquire lock
     DisableProcess

     // Local processing Ensure that objects which have only been
     // accessed on this vp can have their memory reclaimed without
     // waiting for the token.  However we must still wait for the 
     // token to circulate before we can reclaim the id.
     If (prevGenCount ==  0) {
           if (haveToken()) swapsWithToken++;
	   swapgen
	   EnableProcess
           move stage2LocalList to tmpLocalList
           move stage1LocalList to stage2LocalList
     } else { 
           EnableProcess
           release lock
           return
     }

     for each root on tmpLocalList {
         add root->getRef() to localCOIDList
         tassert(root->cleanup(),
                 err_printf("Local object not cleaned properly"));
     } 
     reset tmpLocalList

     Remember that token is not locked and may arrive at any time

     if ( haveToken() ) {
         if (swapsWithToken==1) // do this early for timeliness
             Free ids on reclaimCOIDList;
         
         // wait for 2 swaps with the token. 
	 if (swapsWithToken<2) {
             release lock
             return
         }
	  
         move localCOIDList to reclaimCOIDList;

         For each root on token->TransferArray {
	      if (!root->cleanup()) add to our TransferArray
	      remove from token->TransferArray
         }       

	 For each root on stage1RemoteList {
	      add root->getRef() to reclaimCOIDList;
	      if (!root->cleanup()) add to our TransferArray
	      remove from stage1RemoteList
	 }     
         swapsWithToken = 0;
         handoffToken() // set my token and set next vps token to this;
     }
     release lock
     return
}
    </programlisting>
  </para>

  <para>
Some choices here depending on desired functionality

    <programlisting>
protected:
    CObjRoot::cleanupvp() {
        // Need to be carefull that this does not cause lock problems
        // Ensure that resetLocalEntry does not acquire locks
        DREF(COSMgr)->resetLocalEntry(myRoot->getRef());
	delete this;
        return 0;
    }
        

uval
CObjRootMulti/SingleRep::cleanup()
{
    VPNum thisVp=Scheduler::GetVP();
    uval  thisVpMask= ( 1 << thisvp );

    if (vpMask & thisVpMask) {
         // mark that clean has been called for this vp
         vpMask &= ~thisVpMask;  
         #ifndef DELAYDELETE         
         if (repMask & thisVpMask) {
	    repOnVP(thisVp)->cleanupvp();
            remove from repList;
         }   
         #endif
    }

    if (vpMask == 0) {
        // clean has occurred on all vps with translations
        #ifdef DELAYDELETE
        for each rep in repList {
            remote(vp,rep,cleanvp);  
            remove from repList;
        }
        #endif
        delete this;
        return 1
    }
    return 0;
     
}

    </programlisting>
  </para>

  <para>
    Other Things to consider seperate token spawned for CO's on
    transferlist with the same vpMask. Or just multiple tokens for varies
    sets of vps.  Don't like this leads to a very complicated structure but
    is more timely in memory reclaimation.


  </para>


</section>
