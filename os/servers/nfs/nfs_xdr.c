/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "nfs.h"

bool_t
xdr_filename (XDR *xdrs, filename *objp)
{
	 register long *buf;

	 if (!xdr_string (xdrs, objp, MAXNAMELENGTH))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_path (XDR *xdrs, path *objp)
{
	 register long *buf;

	 if (!xdr_string (xdrs, objp, MAXPATHLENGTH))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_nfsfhandle (XDR *xdrs, nfsfhandle objp)
{
	 register long *buf;

	 if (!xdr_opaque (xdrs, objp, FHSIZE))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_nfscookie (XDR *xdrs, nfscookie *objp)
{
	 register long *buf;

	 if (!xdr_u_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_nfsdata (XDR *xdrs, nfsdata *objp)
{
	 register long *buf;

	 if (!xdr_bytes (xdrs, (char **)&objp->nfsdata_val, (u_int *) &objp->nfsdata_len, MAXDATA))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_nfsstat (XDR *xdrs, nfsstat *objp)
{
	 register long *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ftype (XDR *xdrs, ftype *objp)
{
	 register long *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_timevalue (XDR *xdrs, timevalue *objp)
{
	 register long *buf;

	 if (!xdr_u_int (xdrs, &objp->seconds))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->useconds))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_sattr (XDR *xdrs, sattr *objp)
{
	 register long *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->mode))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->uid))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->gid))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->size))
				 return FALSE;

		} else {
		IXDR_PUT_U_LONG(buf, objp->mode);
		IXDR_PUT_U_LONG(buf, objp->uid);
		IXDR_PUT_U_LONG(buf, objp->gid);
		IXDR_PUT_U_LONG(buf, objp->size);
		}
		 if (!xdr_timevalue (xdrs, &objp->atime))
			 return FALSE;
		 if (!xdr_timevalue (xdrs, &objp->mtime))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->mode))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->uid))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->gid))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->size))
				 return FALSE;

		} else {
		objp->mode = IXDR_GET_U_LONG(buf);
		objp->uid = IXDR_GET_U_LONG(buf);
		objp->gid = IXDR_GET_U_LONG(buf);
		objp->size = IXDR_GET_U_LONG(buf);
		}
		 if (!xdr_timevalue (xdrs, &objp->atime))
			 return FALSE;
		 if (!xdr_timevalue (xdrs, &objp->mtime))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_u_int (xdrs, &objp->mode))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->uid))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->gid))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->size))
		 return FALSE;
	 if (!xdr_timevalue (xdrs, &objp->atime))
		 return FALSE;
	 if (!xdr_timevalue (xdrs, &objp->mtime))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_fattr (XDR *xdrs, fattr *objp)
{
	 register long *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_ftype (xdrs, &objp->type))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 10 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->mode))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->nlink))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->uid))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->gid))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->size))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->blocksize))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->rdev))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->blocks))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->fsid))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->fileid))
				 return FALSE;

		} else {
		IXDR_PUT_U_LONG(buf, objp->mode);
		IXDR_PUT_U_LONG(buf, objp->nlink);
		IXDR_PUT_U_LONG(buf, objp->uid);
		IXDR_PUT_U_LONG(buf, objp->gid);
		IXDR_PUT_U_LONG(buf, objp->size);
		IXDR_PUT_U_LONG(buf, objp->blocksize);
		IXDR_PUT_U_LONG(buf, objp->rdev);
		IXDR_PUT_U_LONG(buf, objp->blocks);
		IXDR_PUT_U_LONG(buf, objp->fsid);
		IXDR_PUT_U_LONG(buf, objp->fileid);
		}
		 if (!xdr_timevalue (xdrs, &objp->atime))
			 return FALSE;
		 if (!xdr_timevalue (xdrs, &objp->mtime))
			 return FALSE;
		 if (!xdr_timevalue (xdrs, &objp->ctime))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_ftype (xdrs, &objp->type))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 10 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->mode))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->nlink))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->uid))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->gid))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->size))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->blocksize))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->rdev))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->blocks))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->fsid))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->fileid))
				 return FALSE;

		} else {
		objp->mode = IXDR_GET_U_LONG(buf);
		objp->nlink = IXDR_GET_U_LONG(buf);
		objp->uid = IXDR_GET_U_LONG(buf);
		objp->gid = IXDR_GET_U_LONG(buf);
		objp->size = IXDR_GET_U_LONG(buf);
		objp->blocksize = IXDR_GET_U_LONG(buf);
		objp->rdev = IXDR_GET_U_LONG(buf);
		objp->blocks = IXDR_GET_U_LONG(buf);
		objp->fsid = IXDR_GET_U_LONG(buf);
		objp->fileid = IXDR_GET_U_LONG(buf);
		}
		 if (!xdr_timevalue (xdrs, &objp->atime))
			 return FALSE;
		 if (!xdr_timevalue (xdrs, &objp->mtime))
			 return FALSE;
		 if (!xdr_timevalue (xdrs, &objp->ctime))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_ftype (xdrs, &objp->type))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->mode))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->nlink))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->uid))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->gid))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->size))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->blocksize))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->rdev))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->blocks))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->fsid))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->fileid))
		 return FALSE;
	 if (!xdr_timevalue (xdrs, &objp->atime))
		 return FALSE;
	 if (!xdr_timevalue (xdrs, &objp->mtime))
		 return FALSE;
	 if (!xdr_timevalue (xdrs, &objp->ctime))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_sattrargs (XDR *xdrs, sattrargs *objp)
{
	 register long *buf;

	 if (!xdr_nfsfhandle (xdrs, objp->file))
		 return FALSE;
	 if (!xdr_sattr (xdrs, &objp->attributes))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_diropargs (XDR *xdrs, diropargs *objp)
{
	 register long *buf;

	 if (!xdr_nfsfhandle (xdrs, objp->dir))
		 return FALSE;
	 if (!xdr_filename (xdrs, &objp->name))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_readargs (XDR *xdrs, readargs *objp)
{
	 register long *buf;

	 if (!xdr_nfsfhandle (xdrs, objp->file))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->offset))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->count))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->totalcount))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_writeargs (XDR *xdrs, writeargs *objp)
{
	 register long *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_nfsfhandle (xdrs, objp->file))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->beginoffset))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->offset))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->totalcount))
				 return FALSE;

		} else {
		IXDR_PUT_U_LONG(buf, objp->beginoffset);
		IXDR_PUT_U_LONG(buf, objp->offset);
		IXDR_PUT_U_LONG(buf, objp->totalcount);
		}
		 if (!xdr_nfsdata (xdrs, &objp->data))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_nfsfhandle (xdrs, objp->file))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->beginoffset))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->offset))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->totalcount))
				 return FALSE;

		} else {
		objp->beginoffset = IXDR_GET_U_LONG(buf);
		objp->offset = IXDR_GET_U_LONG(buf);
		objp->totalcount = IXDR_GET_U_LONG(buf);
		}
		 if (!xdr_nfsdata (xdrs, &objp->data))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_nfsfhandle (xdrs, objp->file))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->beginoffset))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->offset))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->totalcount))
		 return FALSE;
	 if (!xdr_nfsdata (xdrs, &objp->data))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_createargs (XDR *xdrs, createargs *objp)
{
	 register long *buf;

	 if (!xdr_diropargs (xdrs, &objp->where))
		 return FALSE;
	 if (!xdr_sattr (xdrs, &objp->attributes))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_renameargs (XDR *xdrs, renameargs *objp)
{
	 register long *buf;

	 if (!xdr_diropargs (xdrs, &objp->from))
		 return FALSE;
	 if (!xdr_diropargs (xdrs, &objp->to))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_linkargs (XDR *xdrs, linkargs *objp)
{
	 register long *buf;

	 if (!xdr_nfsfhandle (xdrs, objp->from))
		 return FALSE;
	 if (!xdr_diropargs (xdrs, &objp->to))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_symlinkargs (XDR *xdrs, symlinkargs *objp)
{
	 register long *buf;

	 if (!xdr_diropargs (xdrs, &objp->from))
		 return FALSE;
	 if (!xdr_path (xdrs, &objp->to))
		 return FALSE;
	 if (!xdr_sattr (xdrs, &objp->attributes))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_readdirargs (XDR *xdrs, readdirargs *objp)
{
	 register long *buf;

	 if (!xdr_nfsfhandle (xdrs, objp->dir))
		 return FALSE;
	 if (!xdr_nfscookie (xdrs, &objp->cookie))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->count))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_attrstat (XDR *xdrs, attrstat *objp)
{
	 register long *buf;

	 if (!xdr_nfsstat (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS_OK:
		 if (!xdr_fattr (xdrs, &objp->attrstat_u.attributes))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_diropok_tag (XDR *xdrs, diropok_tag *objp)
{
	 register long *buf;

	 if (!xdr_nfsfhandle (xdrs, objp->file))
		 return FALSE;
	 if (!xdr_fattr (xdrs, &objp->attributes))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_diropres (XDR *xdrs, diropres *objp)
{
	 register long *buf;

	 if (!xdr_nfsstat (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS_OK:
		 if (!xdr_diropok_tag (xdrs, &objp->diropres_u.diropok))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_readlinkres (XDR *xdrs, readlinkres *objp)
{
	 register long *buf;

	 if (!xdr_nfsstat (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS_OK:
		 if (!xdr_path (xdrs, &objp->readlinkres_u.data))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_readok_tag (XDR *xdrs, readok_tag *objp)
{
	 register long *buf;

	 if (!xdr_fattr (xdrs, &objp->attributes))
		 return FALSE;
	 if (!xdr_nfsdata (xdrs, &objp->data))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_readres (XDR *xdrs, readres *objp)
{
	 register long *buf;

	 if (!xdr_nfsstat (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS_OK:
		 if (!xdr_readok_tag (xdrs, &objp->readres_u.readok))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_entry (XDR *xdrs, entry *objp)
{
	 register long *buf;

	 if (!xdr_u_int (xdrs, &objp->fileid))
		 return FALSE;
	 if (!xdr_filename (xdrs, &objp->name))
		 return FALSE;
	 if (!xdr_nfscookie (xdrs, &objp->cookie))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->nextentry, sizeof (entry), (xdrproc_t) xdr_entry))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_readdirok_tag (XDR *xdrs, readdirok_tag *objp)
{
	 register long *buf;

	 if (!xdr_pointer (xdrs, (char **)&objp->entries, sizeof (entry), (xdrproc_t) xdr_entry))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->eof))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_readdirres (XDR *xdrs, readdirres *objp)
{
	 register long *buf;

	 if (!xdr_nfsstat (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS_OK:
		 if (!xdr_readdirok_tag (xdrs, &objp->readdirres_u.readdirok))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_info_tag (XDR *xdrs, info_tag *objp)
{
	 register long *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE(xdrs,5 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->tsize))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->bsize))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->blocks))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->bfree))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->bavail))
				 return FALSE;
		} else {
			IXDR_PUT_U_LONG(buf, objp->tsize);
			IXDR_PUT_U_LONG(buf, objp->bsize);
			IXDR_PUT_U_LONG(buf, objp->blocks);
			IXDR_PUT_U_LONG(buf, objp->bfree);
			IXDR_PUT_U_LONG(buf, objp->bavail);
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE(xdrs,5 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->tsize))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->bsize))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->blocks))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->bfree))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->bavail))
				 return FALSE;
		} else {
			objp->tsize = IXDR_GET_U_LONG(buf);
			objp->bsize = IXDR_GET_U_LONG(buf);
			objp->blocks = IXDR_GET_U_LONG(buf);
			objp->bfree = IXDR_GET_U_LONG(buf);
			objp->bavail = IXDR_GET_U_LONG(buf);
		}
	 return TRUE;
	}

	 if (!xdr_u_int (xdrs, &objp->tsize))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->bsize))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->blocks))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->bfree))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->bavail))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_statfsres (XDR *xdrs, statfsres *objp)
{
	 register long *buf;

	 if (!xdr_nfsstat (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS_OK:
		 if (!xdr_info_tag (xdrs, &objp->statfsres_u.info))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}
