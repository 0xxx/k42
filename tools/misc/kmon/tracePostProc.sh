#!/usr/bin/env python
# ############################################################################
# K42: (C) Copyright IBM Corp. 2000.
# All Rights Reserved
#
# This file is distributed under the GNU LGPL. You should have
# received a copy of the License along with K42; see the file LICENSE.html
# in the top-level directory for more details.
#
#  $Id: tracePostProc.sh,v 1.1 2004/02/10 18:40:35 aabauman Exp $
# ############################################################################

import sys

# check for python version > 2.2
major = sys.version_info[0]
minor = sys.version_info[1]
if (not ((major > 2) or (major == 2 and minor >= 2))):
    sys.stderr.write("Error: need Python 2.2 or better, you have %d.%d\n" %
                     (major, minor))
    sys.exit(-1)

# need to define True/False manually for python <2.3
if (major == 2 and minor < 3):
    True = 0 == 0
    False = not True

import string, getopt, os, stat, os.path, glob, tempfile

# default options and constants
options = {"path":          ".",
           "verbose":       False,
           "printFilename": False,
           "runAsPipe":     False,
           "kmonMode":      False,
           "mappedPIDFile": "traceMappedPIDs",
           "filenames":     [],
           "fileGlobs":     ["traceOut*", "traceLockStats*"],
           "kmonGlobs":     ["execStats.txt", "lockStats.txt"],
           "mkAnchor":      "@MKANCHOR@", # this gets inserted at build by sed
           "command":       "powerpc64-linux-addr2line -C -f -e %s",
           "buflen":        4096,
           "searchStr":     "SYM:",
           "kmonMagicStr":  "__kmonflag__\n",
          }

# hash of all unknown PIDs seen so far, used to avoid repeat warnings
unknownPIDCount = {}


def usage():
    print "Usage: %s [OPTION]... [FILE]..." % os.path.basename(sys.argv[0])
    print "Replace symbol addresses with names in the trace output FILEs,"
    print "(or all normal trace output files in current directory, by default)."
    print
    print "    -p PATH, --path=PATH\tspecify path to K42 build directory"
    print "    -f, --filenames\t\tprint file names and line numbers as well"
    print "    -s, --stdin\t\t\tprocess stdin as well, before other files"
    print "    -k, --kmon\t\t\tgenerate file and line data formatted for kmon"
    print ("    -m PATH, --mkanchor=PATH\troot of K42, default: %s"
           % options["mkAnchor"])
    print "    -v, --verbose\t\tbe more verbose while processing"
    print "    -h, --help\t\t\tprint this usage message"
    print
    print ("Requires the file %s (generated by traceProfile),"
           % options["mappedPIDFile"])
    print "and the program %s." % options["command"].split()[0]


def parseArgs(argv):
    try:
        (opts, args) = getopt.getopt(argv, "p:fskm:vh", ["path=", "filenames",
                       "stdin", "kmon", "mkanchor", "verbose", "help"])
    except getopt.GetoptError:
        usage()
        raise RuntimeError

    for (opt, arg) in opts:
        if opt in ("-p", "--path"):
            options["path"] = arg
        elif opt in ("-f", "--filenames"):
            options["printFilename"] = True
        elif opt in ("-s", "--stdin"):
            options["runAsPipe"] = True
        elif opt in ("-k", "--kmon"):
            options["kmonMode"] = True
        elif opt in ("-m", "--mkanchor"):
            options["mkAnchor"] = arg
        elif opt in ("-v", "--verbose"):
            options["verbose"] = True
        elif opt in ("-h", "--help"):
            usage()
            sys.exit(0)

    options["filenames"] = args


def verbose(msg):
    if (options["verbose"]):
        sys.stderr.write(msg)


def parseHexPos(s, pos):
    # drop leading "0x" if it's there
    if (s[pos:pos + 2] == "0x"):
        pos += 2

    # grab characters while they are valid hex digits
    numStr = ""
    while (pos < len(s) and s[pos] in string.hexdigits):
        numStr = numStr + s[pos]
        pos += 1

    return long(numStr, 16), pos


def parseHex(s):
    return parseHexPos(s, 0)[0]


# parse the traceMappedPIDs file
def parseMappedPIDs():
    filename = options["mappedPIDFile"]
    try:
        f = open(filename, "r")
    except IOError:
        sys.stderr.write("Error: couldn't open %s\n" % filename)
        raise RuntimeError

    mappedPIDs = {}
    line = f.readline()
    while (line != ""):
        try:
            (pid, textOff, filename) = string.split(line)
            mappedPIDs[parseHex(pid)] = filename
        except:
            sys.stderr.write("Error: couldn't parse %s\n" % filename)
            raise RuntimeError
        line = f.readline()
    f.close()

    verbose("Read mappings for %d PID(s) from %s\n" % (len(mappedPIDs), f.name))

    return mappedPIDs


# open the addr2line subprocess for the given image file
def openProc(filename):
    if (options["path"] == "." or os.path.isabs(filename)):
        fullPath = filename
    else:
        fullPath = os.path.expanduser(os.path.join(options["path"], filename))
    if (not os.path.isfile(fullPath)):
        sys.stderr.write("Error: couldn't access %s for symbols\n" % fullPath)
        raise RuntimeError

    cmd = options["command"] % fullPath
    try:
        ret = os.popen2(cmd)
    except OSError:
        sys.stderr.write("Error: couldn't popen %s\n" % cmd)
        raise RuntimeError

    return ret


# return method name, file name, and line number for a given symbol address
def getSym(procs, pid, addr):
    try:
        (outFD, inFD) = procs[pid]
    except KeyError:
        if (pid in unknownPIDCount):
            unknownPIDCount[pid] += 1
        else:
            unknownPIDCount[pid] = 1
        return None, None, 0

    try:
        outFD.write("0x%lx\n" % addr)
        outFD.flush()
        methodStr = inFD.readline().strip()
        fileStr = inFD.readline().strip()
    except IOError:
        sys.stderr.write("Error talking to child process\n")
        raise RuntimeError

    try:
        splitPos = string.rindex(fileStr, ':')
        fileName = fileStr[:splitPos]
        lineNo = int(fileStr[splitPos + 1:])
    except:
        sys.stderr.write("Error parsing output from child process\n")
        raise RuntimeError

    if (fileName == "??"):
        fileName = None
    else:
        # remove common path prefix, if it's there
        prefix = options["mkAnchor"]
        if (prefix[-1] != '/'):
            prefix = prefix + '/'
        if (os.path.commonprefix([fileName, prefix]) == prefix):
            fileName = fileName[len(prefix):]

    if (methodStr[0] == '.'):
        methodStr = methodStr[1:]
    elif (methodStr == "??"):
        methodStr = None

    return methodStr, fileName, lineNo


# returns replacement string to go inline
def makeReplacement(pid, addr, methodStr, fileName, lineNo):
    if (methodStr is None):
        methodStr = "?? (0x%lx:0x%lx)" % (pid, addr)

    if (fileName is not None and options["printFilename"]):
        return methodStr + " " + fileName + ":" + str(lineNo)
    else:
        return methodStr


# returns magic lines to be output for kmon tool
def kmonMagic(fileName, lineNo):
    if (fileName is None):
        return options["kmonMagicStr"] + "unknownFile 0\n"
    else:
        return options["kmonMagicStr"] + fileName + " " + str(lineNo) + "\n"


# filter all symbol strings in inFile, replacing them in output to outFile
def filterFile(procs, inFile, outFile):
    line = inFile.readline()
    lineNo = 1
    symCount = 0
    searchStr = options["searchStr"]
    while (line != ""):
        startPos = string.find(line, searchStr)
        while (startPos != -1):
            pid, sepPos = parseHexPos(line, startPos + len(searchStr))
            if (line[sepPos] != ':'):
                sys.stderr.write("Error: %s:%d is bogus\n"
                                 % (inFile.name, lineNo))
                raise RuntimeError
            addr, endPos = parseHexPos(line, sepPos + 1)

            methodStr, fileName, lineNo = getSym(procs, pid, addr)

            newStr = makeReplacement(pid, addr, methodStr, fileName, lineNo)
            line = line[:startPos] + newStr + line[endPos:]
            symCount += 1

            if (options["kmonMode"]):
                outFile.write(kmonMagic(fileName, lineNo))

            startPos = string.find(line, searchStr, startPos + len(newStr))

        outFile.write(line)
        line = inFile.readline()
        lineNo += 1

    verbose(" replaced %d symbol(s)" % symCount)

    return 0


# rewrite the file "filename" with symbol names inserted
def rewriteFile(procs, filename):
    try:
        inFile = open(filename, 'r+')
    except IOError:
        sys.stderr.write("Error: couldn't open %s\n" % filename)
        raise RuntimeError

    # temporary file to hold new version
    outFile = tempfile.TemporaryFile()

    verbose("Processing file %s..." % filename)

    try:
        filterFile(procs, inFile, outFile)
    except RuntimeError:
        inFile.close()
        outFile.close()
        raise RuntimeError

    # now copy the new file over the old one
    # could do this with a rename(), but renaming a tempfile causes problems
    outFile.seek(0)
    inFile.seek(0)
    inFile.truncate()

    buf = outFile.read(options["buflen"])
    while (buf != ""):
        inFile.write(buf)
        buf = outFile.read(options["buflen"])

    outFile.close()
    inFile.close()

    verbose(", done.\n");


def runAsPipe(procs):
    verbose("Processing stdin...")
    filterFile(procs, sys.stdin, sys.stdout)
    verbose(", done.\n")


def main(args):
    parseArgs(args)

    # This is a fairly nasty hack. if running as a pipe, ie. processing live
    # traceProfile output, we need to wait for it to write the mapped PIDs file.
    # Assume the first output won't be a symbol, and get it before continuing.
    if (options["runAsPipe"]):
        sys.stdout.write(sys.stdin.read(1))

    mappedPIDs = parseMappedPIDs()
    if (mappedPIDs is None):
        return -1

    subProcs = {}
    openFiles = {}
    for (pid, filename) in mappedPIDs.items():
        if (filename in openFiles):
            subProcs[pid] = openFiles[filename]
        else:
            fds = openProc(filename)
            subProcs[pid] = fds
            openFiles[filename] = fds

    verbose("Opened %d addr2line subprocess(es)\n" % len(openFiles))

    filenames = options["filenames"]
    if (filenames == []):
        if (options["kmonMode"]):
            globs = options["kmonGlobs"]
        else:
            globs = options["fileGlobs"]
        for globStr in globs:
            filenames.extend(glob.glob(globStr))

    if (options["runAsPipe"]):
        runAsPipe(subProcs)

    for filename in filenames:
        rewriteFile(subProcs, filename)

    for (f1, f2) in openFiles.values():
        f1.close()
        f2.close()

    unknowns = unknownPIDCount.items()
    if (unknowns != []):
        unknowns.sort(lambda (p1,c1), (p2,c2): cmp(c2, c1))
        sys.stderr.write("Warning: unknown PID(s):")
        for (pid, count) in unknowns:
            sys.stderr.write("  0x%lx (%d)" % (pid, count))
        sys.stderr.write("\n")

    verbose("All done!\n")

    return 0


if __name__ == "__main__":
    try:
        sys.exit(main(sys.argv[1:]))
    except RuntimeError:
        sys.exit(-1)
